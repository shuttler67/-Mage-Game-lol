#!/usr/home/thomas/git/-Mage-Game-lol/PixelToy\ 1.4

class AStar:
	@staticmethod
	def estimateHeuristicTo(goal, node):
		deltaX = abs(goal.worldx - node.worldx)
		deltaY = abs(goal.worldy - node.worldy)
		return min(deltaX, deltaY) * 1.4 + max(deltaX, deltaY) - min(deltaX, deltaY)
		
<<<<<<< HEAD
	def search(self):
		pass
				
	def draw(self,cameraX,cameraY):
		
		if self.inAttack:
			self.animspeed+=1
			if self.animspeed<30:
				drawImage(charge1,self.x-cameraX,self.y-cameraY,MANSIZE,MANSIZE)
			else:
				drawImage(charge2,self.x-cameraX,self.y-cameraY,MANSIZE,MANSIZE)
			if self.animspeed>60:
				self.animspeed=0
		elif self.isMoving:
			self.animspeed+=1
			if RIGHT in self.directions:
				if self.animspeed<12:
					drawImage(walk3,self.x-cameraX,self.y-cameraY,MANSIZE,MANSIZE)
				else:
					drawImage(walk4,self.x-cameraX,self.y-cameraY,MANSIZE,MANSIZE)
			if LEFT in self.directions:
				if self.animspeed<12:
					drawImage(walk1,self.x-cameraX,self.y-cameraY,MANSIZE,MANSIZE)
				else:
					drawImage(walk2,self.x-cameraX,self.y-cameraY,MANSIZE,MANSIZE)
			if self.animspeed>24:
				self.animspeed=0
		else:
			drawImage(still,self.x-cameraX,self.y-cameraY,MANSIZE,MANSIZE)
#Player class

#GUI class

class GUI:
	def __init__(self):
		self.buttons = [Button(0,_screenHeight-35,100,'pause','pause')]
	def update(self,pause):
		if pause:
			self.buttons = [Button(_screenWidth/2-100,_screenHeight/2,200,'resume game','unpause'),Button(_screenWidth/2-100,_screenHeight/2-35,200,'main menu',NIL)]
		else:
			self.buttons = [Button(0,_screenHeight-35,100,'pause','pause')]
	def handleMouseUp(self):
		returnValue = NIL
		overButton = False
		for button in self.buttons:
			if button.isUnderMouse():
				overButton = True
				returnValue = button.returnValue
		return returnValue, overButton
	def drawButtons(self):
		for button in self.buttons:
			button.draw()
	def draw(self,health,mana,maxHealth,maxMana):
		barWidth = _screenWidth/3
		useColourList(GREY)
		drawRectangle(_screenWidth/2-barWidth/2,_screenHeight-19,barWidth,17)
		drawRectangle(_screenWidth/2-barWidth/2,_screenHeight-37,barWidth,17)

		useColourList(RED)
		drawRectangle(_screenWidth/2-barWidth/2+3, _screenHeight-17, health/maxHealth*(barWidth-4), 13)
		useColourList(BLUE)
		drawRectangle(_screenWidth/2-barWidth/2+2,_screenHeight-35,mana/maxMana*(barWidth-4), 13)

		useColourList(WHITE)
		drawString(_screenWidth/2-len(str(int(health)))*6,_screenHeight-18,str(int(health)))
		drawString(_screenWidth/2-len(str(int(mana)))*6,_screenHeight-36,str(int(mana)))
#GOOEY class

#Level Up! class
class Level:
	def __init__(self,levelDICT): 
		self.walls = levelDICT["WALLS"]
		self.enemies = levelDICT["ENEMIES"]
		self.projSize = 3
		self.proj = []
	def handleObjects(self,manX,manY,cameraX,cameraY):
		canNotMoves = []			
=======
	class Node:
		def __init__(self, worldx, worldy, cameFromPos = None):
			self.worldx, self.worldy = worldx, worldy
			self.cameFromPos = cameFromPos
		def calculateScores(self, distanceFromStart, goal):
			self.g_score = distanceFromStart
			self.f_score = AStar.estimateHeuristicTo(goal, self)+self.g_score
>>>>>>> c590da6fd2046e6b9be23538d06c58bdd8fef8b5
			
		def __eq__(self, node2):
			return self.worldx == node2.worldx and self.worldy == node2.worldy
			
		def neighbourNodes(self, goal):
			neighbours =[]
			for worldx in range(-1,2):
				for worldy in range(-1,2):
					distance = 1
					if abs(worldx)+abs(worldy) == 2:
						distance = 1.4
					if not worldx == worldy == 0:
						neighbours.append(AStar.Node(self.worldx+worldx,self.worldy+worldy,(self.worldx,self.worldy)))
			for neighbour in neighbours:
				neighbour.calculateScores(self.g_score+distance, goal)
	    		return neighbours
	
	def __init__(self, start, goal):
		self.start = AStar.Node(*start)
		self.goal = AStar.Node(*goal)
		self.start.calculateScores(0, self.goal)
		self.openNodes = [self.start]
		self.closedNodes = []
		
	def recoverPath(self):
		nodePath = [self.goal]
		path = []
		
		while not nodePath[0] == self.start:
			nodePath.insert(0,self.closedNodes[self.closedNodes.index(AStar.Node(*path.cameFrom))])
		
		for node in nodePath:
			path.append((node.x, node.y))
		
		return path

	def findPath(self, canMoveTo):
		foundGoal = False
		fail = False
		while not foundGoal and not fail:
			if len(self.openNodes) != 0:
				min_f_score = self.openNodes[0].f_score
				bestNodeIndex = 0
				for n in range(len(self.openNodes)):
					if self.openNodes[n].f_score < min_f_score:
						bestNodeIndex = n
				currentNode = self.openNodes[bestNodeIndex]
				self.openNodes.pop(bestNodeIndex)
				if currentNode == self.goal:
					foundGoal = True
					continue
				currentNeighbours = currentNode.neighbourNodes(self.goal)
				
				for neighbour in currentNeighbours:
					if neighbour in self.closedNodes:
						currentNeighbours.remove(neighbour)
							
					if neighbour in self.openNodes:
						open_index = self.openNodes.index(neighbour)
						if neighbour.g_score < self.openNodes[open_index].g_score:
							self.openNodes.pop(open_index)
						else:
							currentNeighbours.remove(neighbour)
							
					if not canMoveTo():
						currentNeighbours.remove(neighbour)
				
				self.openNodes += currentNeighbours
							
				self.closedNodes.append(currentNode)
			else:
				fail = True

		if fail:
			return
		else:
			return self.recoverPath()

def canMoveTo():
	return True
 
a = AStar((0,0),(1,1))
a.findPath(canMoveTo)
while True:
	newFrame()
	for o_node in a.openNodes:
		useColour(255,0,0,255)
		drawPoint(o_node.worldx, o_node.worldy)
	for c_node in a.closedNodes:
		useColour(0, 0, 255, 255)
		drawPoint(c_node.worldx, c_node.worldy)
